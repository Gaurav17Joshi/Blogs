---
layout: post
title: "GSoC - Community Bonding"
subtitle: "Work in Community Bonding"
date: 2023-06-02
background: '/img/posts/GSoC.png'
tags: gsoc
---

## The implementation
In the first two weeks I focussed on understanding the implementation of the project. In the source repository Celerite library was used for GP implimentation and Bilby was used for Bayesian Inferencing, while in my project my mentor and I decided to completely use a Jax based backend hense, Tinygp for GP, and Jaxns for Nested Sampling.

I made a proof of Concept implimentation for the QPO kernel and gaussian mean model for a lightcurve, which is explained in breif here:-

### Kernel:
For making the Kernel, I used Tingp.quasisep.celerite kernels which are a fast implementation (based on the celerite kernel) of the Qpo kernel.

$$  k_{qpo+rn}(\tau) = k_{qpo}(\tau) + k_{rn}(\tau)   $$
$$  k_{qpo+rn}(\tau) = a_{qpo} \exp(-c_{qpo} \tau) \cos(2\pi f \tau) + a_{rn} \exp(-c_{rn} \tau)  $$

The `quasisep.exp` kernel for the red noise part and the `quasisep.celerite` kernel for the qpo part can be implemented as:
```python
hqpokernel = kernels.quasisep.Exp(
    scale = 1/hqpoparams["crn"], sigma = (hqpoparams["arn"])**0.5) + kernels.quasisep.Celerite(
        a = hqpoparams["aqpo"], b = 0.0, c = hqpoparams["cqpo"], d = 2*jnp.pi*hqpoparams["freq"])
```

<img src="{{site.baseurl}}/img/assets/kernel1.png" alt="Plot of High, low and non QPO kernel">



## Jaxns and its use


## Tensor flow probability


## My adventure with the implimentation

